{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { parseUpdateArgs } from \"./utils\";\nimport { buildNativeMap } from \"./utils/serialize\";\nimport DocumentSnapshot from \"./DocumentSnapshot\";\nimport { getNativeModule } from \"../../utils/native\";\n\nvar Transaction = function () {\n  function Transaction(firestore, meta) {\n    _classCallCheck(this, Transaction);\n\n    this._meta = meta;\n    this._commandBuffer = [];\n    this._firestore = firestore;\n    this._pendingResult = undefined;\n  }\n\n  _createClass(Transaction, [{\n    key: \"_prepare\",\n    value: function _prepare() {\n      this._commandBuffer = [];\n      this._pendingResult = undefined;\n    }\n  }, {\n    key: \"get\",\n    value: function get(documentRef) {\n      var _this = this;\n\n      return getNativeModule(this._firestore).transactionGetDocument(this._meta.id, documentRef.path).then(function (result) {\n        return new DocumentSnapshot(_this._firestore, result);\n      });\n    }\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this._commandBuffer.push({\n        type: 'set',\n        path: documentRef.path,\n        data: buildNativeMap(data),\n        options: options || {}\n      });\n\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(documentRef) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var data = parseUpdateArgs(args, 'Transaction.update');\n\n      this._commandBuffer.push({\n        type: 'update',\n        path: documentRef.path,\n        data: buildNativeMap(data)\n      });\n\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef) {\n      this._commandBuffer.push({\n        type: 'delete',\n        path: documentRef.path\n      });\n\n      return this;\n    }\n  }]);\n\n  return Transaction;\n}();\n\nexport { Transaction as default };","map":{"version":3,"names":["parseUpdateArgs","buildNativeMap","DocumentSnapshot","getNativeModule","Transaction","firestore","meta","_meta","_commandBuffer","_firestore","_pendingResult","undefined","documentRef","transactionGetDocument","id","path","then","result","data","options","push","type","args"],"sources":["C:/Users/PC/Desktop/All/StoreApp2/my-app/node_modules/react-native-firebase/dist/modules/firestore/Transaction.js"],"sourcesContent":["/**\n * \n * Firestore Transaction representation wrapper\n */\nimport { parseUpdateArgs } from './utils';\nimport { buildNativeMap } from './utils/serialize';\nimport DocumentSnapshot from './DocumentSnapshot';\nimport { getNativeModule } from '../../utils/native';\n// TODO docs state all get requests must be made FIRST before any modifications\n// TODO so need to validate that\n\n/**\n * @class Transaction\n */\nexport default class Transaction {\n  constructor(firestore, meta) {\n    this._meta = meta;\n    this._commandBuffer = [];\n    this._firestore = firestore;\n    this._pendingResult = undefined;\n  }\n  /**\n   * -------------\n   * INTERNAL API\n   * -------------\n   */\n\n  /**\n   * Clears the command buffer and any pending result in prep for\n   * the next transaction iteration attempt.\n   *\n   * @private\n   */\n\n\n  _prepare() {\n    this._commandBuffer = [];\n    this._pendingResult = undefined;\n  }\n  /**\n   * -------------\n   *  PUBLIC API\n   * -------------\n   */\n\n  /**\n   * Reads the document referenced by the provided DocumentReference.\n   *\n   * @param documentRef DocumentReference A reference to the document to be retrieved. Value must not be null.\n   *\n   * @returns Promise<DocumentSnapshot>\n   */\n\n\n  get(documentRef) {\n    // todo validate doc ref\n    return getNativeModule(this._firestore).transactionGetDocument(this._meta.id, documentRef.path).then(result => new DocumentSnapshot(this._firestore, result));\n  }\n  /**\n   * Writes to the document referred to by the provided DocumentReference.\n   * If the document does not exist yet, it will be created. If you pass options,\n   * the provided data can be merged into the existing document.\n   *\n   * @param documentRef DocumentReference A reference to the document to be created. Value must not be null.\n   * @param data Object An object of the fields and values for the document.\n   * @param options SetOptions An object to configure the set behavior.\n   *        Pass {merge: true} to only replace the values specified in the data argument.\n   *        Fields omitted will remain untouched.\n   *\n   * @returns {Transaction}\n   */\n\n\n  set(documentRef, data, options) {\n    // todo validate doc ref\n    // todo validate data is object\n    this._commandBuffer.push({\n      type: 'set',\n      path: documentRef.path,\n      data: buildNativeMap(data),\n      options: options || {}\n    });\n\n    return this;\n  }\n  /**\n   * Updates fields in the document referred to by this DocumentReference.\n   * The update will fail if applied to a document that does not exist. Nested\n   * fields can be updated by providing dot-separated field path strings or by providing FieldPath objects.\n   *\n   * @param documentRef DocumentReference A reference to the document to be updated. Value must not be null.\n   * @param args any Either an object containing all of the fields and values to update,\n   *        or a series of arguments alternating between fields (as string or FieldPath\n   *        objects) and values.\n   *\n   * @returns {Transaction}\n   */\n\n\n  update(documentRef, ...args) {\n    // todo validate doc ref\n    const data = parseUpdateArgs(args, 'Transaction.update');\n\n    this._commandBuffer.push({\n      type: 'update',\n      path: documentRef.path,\n      data: buildNativeMap(data)\n    });\n\n    return this;\n  }\n  /**\n   * Deletes the document referred to by the provided DocumentReference.\n   *\n   * @param documentRef DocumentReference A reference to the document to be deleted. Value must not be null.\n   *\n   * @returns {Transaction}\n   */\n\n\n  delete(documentRef) {\n    // todo validate doc ref\n    this._commandBuffer.push({\n      type: 'delete',\n      path: documentRef.path\n    });\n\n    return this;\n  }\n\n}"],"mappings":";;AAIA,SAASA,eAAT;AACA,SAASC,cAAT;AACA,OAAOC,gBAAP;AACA,SAASC,eAAT;;IAOqBC,W;EACnB,qBAAYC,SAAZ,EAAuBC,IAAvB,EAA6B;IAAA;;IAC3B,KAAKC,KAAL,GAAaD,IAAb;IACA,KAAKE,cAAL,GAAsB,EAAtB;IACA,KAAKC,UAAL,GAAkBJ,SAAlB;IACA,KAAKK,cAAL,GAAsBC,SAAtB;EACD;;;;WAeD,oBAAW;MACT,KAAKH,cAAL,GAAsB,EAAtB;MACA,KAAKE,cAAL,GAAsBC,SAAtB;IACD;;;WAgBD,aAAIC,WAAJ,EAAiB;MAAA;;MAEf,OAAOT,eAAe,CAAC,KAAKM,UAAN,CAAf,CAAiCI,sBAAjC,CAAwD,KAAKN,KAAL,CAAWO,EAAnE,EAAuEF,WAAW,CAACG,IAAnF,EAAyFC,IAAzF,CAA8F,UAAAC,MAAM;QAAA,OAAI,IAAIf,gBAAJ,CAAqB,KAAI,CAACO,UAA1B,EAAsCQ,MAAtC,CAAJ;MAAA,CAApG,CAAP;IACD;;;WAgBD,aAAIL,WAAJ,EAAiBM,IAAjB,EAAuBC,OAAvB,EAAgC;MAG9B,KAAKX,cAAL,CAAoBY,IAApB,CAAyB;QACvBC,IAAI,EAAE,KADiB;QAEvBN,IAAI,EAAEH,WAAW,CAACG,IAFK;QAGvBG,IAAI,EAAEjB,cAAc,CAACiB,IAAD,CAHG;QAIvBC,OAAO,EAAEA,OAAO,IAAI;MAJG,CAAzB;;MAOA,OAAO,IAAP;IACD;;;WAeD,gBAAOP,WAAP,EAA6B;MAAA,kCAANU,IAAM;QAANA,IAAM;MAAA;;MAE3B,IAAMJ,IAAI,GAAGlB,eAAe,CAACsB,IAAD,EAAO,oBAAP,CAA5B;;MAEA,KAAKd,cAAL,CAAoBY,IAApB,CAAyB;QACvBC,IAAI,EAAE,QADiB;QAEvBN,IAAI,EAAEH,WAAW,CAACG,IAFK;QAGvBG,IAAI,EAAEjB,cAAc,CAACiB,IAAD;MAHG,CAAzB;;MAMA,OAAO,IAAP;IACD;;;WAUD,iBAAON,WAAP,EAAoB;MAElB,KAAKJ,cAAL,CAAoBY,IAApB,CAAyB;QACvBC,IAAI,EAAE,QADiB;QAEvBN,IAAI,EAAEH,WAAW,CAACG;MAFK,CAAzB;;MAKA,OAAO,IAAP;IACD;;;;;;SAlHkBX,W"},"metadata":{},"sourceType":"module"}